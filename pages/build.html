<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"> 
  <meta http-equiv="x-ua-compatible" content="ie=edge">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- favicon links -->
  <link rel="apple-touch-icon" sizes="120x120" href="../apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
  <link rel="manifest" href="../site.webmanifest">
  <link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">  

  <meta name="keywords" content="JavaScript, primes, prime numbers, Ulam spiral">
  <meta name="author" content="Sophie Stammers">
  <title>Building a JavaScript Ulam spiral</title>

  <!-- OG markup -->
  <meta prefix="og: http://ogp.me/ns#" property="og:type" content="website" />
  <meta prefix="og: http://ogp.me/ns#" property="og:title" content="Building a JavaScript
  Ulam spiral" />
  <meta prefix="og: http://ogp.me/ns#" property="og:description" content="An Ulam spiral is a way to demonstrate, visually, that there are sequences in the number system with high densities of primes. You can build one with 50 lines of JavaScript. Here's how, and why." />
  <meta prefix="og: http://ogp.me/ns#" property="og:image" content="https://ammersive.github.io/ulam/assets/ulam-transformed-sm.jpg" />
  <meta prefix="og: http://ogp.me/ns#" property="og:url" content="https://ammersive.github.io/ulam/pages/build.html" /> 
  
  <!-- Twitter card mark-up -->
  <meta name="twitter:card" content="https://ammersive.github.io/ulam/assets/ulam-transformed-sm.jpg" />
  <meta name="twitter:site" content="@ammersive" />
  <meta name="twitter:domain" content="https://ammersive.github.io/ulam/pages/build.html" />
  <meta name="twitter:title" content="JavaScript Ulam spiral" />
  <meta name="twitter:description" content="An Ulam spiral is a way to demonstrate, visually, that there are sequences in the number system with high densities of primes. You can build one with 50 lines of JavaScript. Here's how, and why." />  
  
  <!-- Grid logic -->
  <script defer src="../scripts/spiral-nums.js"></script>
  <script defer src="../scripts/traversal.js"></script>
  <script defer src="../scripts/paths.js"></script>
  <script defer src="../scripts/ulam.js"></script>

  <!-- Styles and CDNs -->
  <script src="https://kit.fontawesome.com/2e178b2af8.js" crossorigin="anonymous"></script> 
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Bodoni+Moda:wght@500&family=IBM+Plex+Mono&family=Poppins:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles/main.css">
</head>

<body>
  <section class="container">

    <article class="article">

      <header class="page-header">
          <h1>Building a JavaScript<br> Ulam spiral</h1>
          <p class="author">by <a href="https://ammersive.github.io/portfolio/" target="_blank" rel="noopener noreferrer">Sophie Stammers</a></p>
      </header>

      <p class="back"><a href="../index.html">back</a></p>

      <h2>Contents</h2>
      <ul class="contents">
        <li><a href="#intro">Truly, untameably wild?</a></li>
        <li><a href="#building">Building the grid</a></li>
        <li><a href="#prime-func">Prime checker function    </a></li>
        <li><a href="#questions">Three questions</a></li>
        <li><a href="#traversing">Traversing the grid</a></li>
        <li><a href="#colouring">Colouring in the primes</a></li>
        <li><a href="#spiral">Moving in a spiral</a></li>
        <li><a href="#answers">Three answers</a></li>
        <li><a href="#shebang">The whole shebang</a></li>
        <li><a href="#next">What next?</a></li>
      </ul>

      <div id="intro">

        <h3>Truly, untameably wild?</h3>
        <a href="#prime-func"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>Prime numbers (those that are divisible by only themselves and one) are mathematically wild. Unlike, say, the even numbers, the primes famously elude the capture and discipline of a neat mathematical formula. Compare: For any given even number, we have a tidy formula from which we can tell where we’ll find the next even number, it’s just <span class="formula">n + 2</span>.</p> 
          
        <p>Not so for the primes. Take your favourite prime number. Maybe it’s 3, or 17, or even 65537. There is currently no known generalisable mathematical statement from which we can deduce how far up the sequence of the natural (whole) numbers the next prime lies.</p> 

        <p>So, are the primes scattered at random throughout the sequence of natural numbers? Not exactly. <a href="https://en.wikipedia.org/wiki/Formula_for_primes#Prime_formulas_and_polynomial_functions" target="_blank" rel="noopener noreferrer">Some formulas</a> generate significantly many primes for us to conclude that order and predictability pervade at least some subsets of the primes. But a formula that captures them all, whilst also being efficiently computable is not known (and we'll have a few things to say about efficient computability later on...).</p>  
          
        <p>There is, however, a little conjuring trick we can perform to unveil a series of sequences and patters that dwell amongst the primes, sequences which even our best prime formulas cannot wholly explain. What's more, we can do it using just coloured pencils and graph paper!</p> 

        <p>In principle, at least. For whilst this conjuring trick is easy, it certainly is repetitive. Here’s the deal. Put your pencil in the middle of your graph paper and write a “1”. Go up one square and write “2”. Go left and write “3”. Keep going, inputting the next number to the next square, working in a tight spiral around 1 until you have something that looks like this:</p>  

        <div id="spiGrid" class="spi-grid"></div>

        <p>Now, go around again, but this time, every time you find a prime number, colour in that square. If you have the patience to do this for all of the cells in, say, a 100 x 100 grid, you will witness the emergence of a haunting and beautiful pattern, in which many of the prime numbers – far more than would be expected by chance, and far more than for a number series that is truly, untameably wild –  line up in long diagonal stretches that criss-cross the page.</p> 

        <p>Alas, dear reader. I do <em class="italic">not</em> have this patience. But, I have always had a deep desire to generate for myself the mysterious Ulam spiral (first discovered by mathematician Stanisław Ulam in 1963, and popularized by Martin Gardner) in some way. The precise way became clear last year as I started learning programming: I could get my computer to do the colouring in bit for me.</p>        

        <p>There are three stages to the project:</p>
        
        <ol class="list">
          <li>Create a <strong>grid of squares</strong>, where we have <strong>control over the colour</strong> of the squares.</li> 
          <li>Write a bit of code that can <strong>identify if a number is prime</strong>.</li>
          <li>Write a bit of code that specifies the <strong>spiralling movement across the grid</strong>.</li>
        </ol>

        <p>We're going to take a pretty rigorous walk through the code over the next few sections. But because I am assuming that you, dear reader, are a human, and not the JavaScript engine, we'll be doing this in stages, following a narrative that does not precisely match the order of the code itself from top to bottom. So if you want to take a look at the complete code repository, you can find that <a href="https://github.com/ammersive/ulam" target="_blank">here</a>. For the main JavaScript algorithms, have a look at the <span class="inline-code">scripts/ulam.js</span> file in the <a href="https://github.com/ammersive/ulam" target="_blank">code repository</a>. There's also this <a href="#shebang" target="_blank">this reproduction</a> of those algorithms.</p>
        
        <p>Let's get started!</p>

      </div>  
      <div id="building">

        <a href="#intro"><i class="fas fa-chevron-up" aria-label="up"></i></a>
        <h3>Building the grid</h3>
        <a href="#prime-func"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>I’ve chosen to go with a 100 x 100 grid, which means we need to create 10,000 grid squares. We’ll be using the HTML equivalent of a square, an element called a <em>span</em>.</p>
                  
        <p>Here's one now, look: <span class="demo"></span></p> 
          
        <p>We can then use the styling language CSS to tell these spans how big and what colour to be. So, from now on I’ll talk about “spans” – just think of them as squares that we can display on a webpage.</p> 

        <p>We want each span to be pretty much identical except for whether or not they are coloured in. So, here’s our first job for JavaScript, the programming language we’ll be using to get the main logic into the project. Let’s first declare some variables – words that will store the values of important data that we’ll want to reuse in the project. We said that the grid would be 100 spans wide/high, so we’ll store that value in a <span class="inline-code">gridLength</span> variable, which we can multiply by itself to get the total number of spans in the grid (<span class="inline-code">gridSize</span>), which will also be an important value to keep track of for later. Let's head on over to the main JavaScript file (which is <span class="inline-code">scripts/ulam.js</span> in the code repo linked above) and make lots of spans!</p>

        <div class="terminal">
          <ol class="code">
            <li>let gridLength = 100;</li>
            <li>let gridSize = gridLength * gridLength;</li>
            <li>let spanArray = [];</li>
            <li>for (let i = 0; i < gridSize; i += 1) {</li>
            <li>&nbsp; span = d.createElement("span");</li>
            <li>&nbsp; spanArray.push(span);</li>    
            <li>}</li>
          </ol>
        </div> 

        <p>The main “making” action happens on line 4, the line that starts with the word “for”, up to line 7. We have here a fundamental computing procedure: a loop (in this case, a “for loop”), which allows us to perform some given operation over and over again, until some condition is met. The operations running inside this loop (lines 5 and 6) are almost interpretable in English. They basically say: create a span, and then put that span inside a thing we’re calling <span class="inline-code">spanArray</span>.</p>          

        <p>An array is a way to store data. It’s a container where we can keep the spans together, and then access them all at once later on. Line 4 is the bit that specifies <em class="italic">how many</em> spans we should make: start a count at 0, and then make a span, and every time we make a span, plus one to this count. Repeat this procedure over and over, stopping when the count reaches the number stored in the variable <span class="inline-code">gridSize</span>, which in this case is 10,000.</p>

        <p>We now have 10,000 spans, stored in a list and ready to go. That was quick! We still need to do a bit of styling to get things looking grid-like. For one thing, we need to actually put them on our page, but we’ll do that right at the end when we’ve done the prime number bit.</p>
          
        <p>At present, these spans won’t have any dimensions or colour. We'll need to change that if we actually want to see them on our page. We'll do this in our CSS file, <span class="inline-code">styles/ulam-main.css</span> if you're following the repo. Let’s first make a container to house our spans once they get to the page. We'll give it a width and a height that is a multiple of our chosen <span class="inline-code">gridLength</span>.</p>
        
        <div class="terminal">
          <p class="code">
            .main-grid {<br> 
            &nbsp; width: 600px;<br> 
            &nbsp; height: 600px;<br>
            }         
            </p>
        </div> 

        <p>Then, we set each span element to be container size / <span class="inline-code">gridLength</span> pixels high and wide. By default, the spans want to stack on top of each other, in a long line vertically down the page. <span class="inline-code">float: left</span> tells them to fill the first row, sitting next to each other like words on a page until they reach the edge of the grid, and then fill the next row… and so on. We’ll also give them a nice minty colour so we can see them.</p> 

        <div class="terminal">
          <p class="code">
            .main-grid span {<br>
            &nbsp; height: 6px;<br>
            &nbsp; width: 6px;<br>
            &nbsp; float: left;<br>
            &nbsp; background-color: rgb(200, 249, 232);<br>  
            }        
          </p>
        </div> 

        <p>We still won't see anything just yet. That's because we haven't yet sent the spans we made in the JavaScript file onto the HTML page. We'll do that once we've worked out which spans need to be prime.</p>

        <p>The final bit of CSS set up is to define the additional class that will allow our prime spans to show up in the grid. All we need to do is give them a different background colour. Let's use a dark green:</p>

        <div class="terminal">
          <p class="code">
            .main-grid .prime {<br>
            &nbsp; background-color: rgb(4, 56, 57);<br>
            }        
          </p>
        </div> 

        <p>Now let's find some primes!</p>

      </div>
      <div id="prime-func">

        <a href="#building"><i class="fas fa-chevron-up" aria-label="up"></i></a>  
        <h3>Prime checker function</h3>
        <a href="#questions"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>Before we tell JavaScript to get out its colouring pencils and go to town on our grid, we need a way to work out, for any given number: is that number prime? I’m going to do this with a function, a reusable bit of code that allows us ask that same question, but feed in any number of different values (which is useful, because there are quite a lot of numbers out there…). Here it is:</p>

        <div class="terminal">
          <ol class="code">
            <li>let prime = num => {</li>
            <li>&nbsp; let isPrime = true;</li> 
            <li>&nbsp; if (num <= 1) {</li>
            <li>&nbsp; &nbsp; isPrime = false;</li>
            <li>&nbsp; } else {</li> 
            <li>&nbsp; &nbsp; for (i = 2; i <= (num / 2); i += 1) {</li>
            <li>&nbsp; &nbsp; &nbsp; if (num % i === 0) {</li>
            <li>&nbsp; &nbsp; &nbsp; &nbsp; isPrime = false;</li>
            <li>&nbsp; &nbsp; &nbsp; }</li>
            <li>&nbsp; &nbsp; }</li>   
            <li>&nbsp; }</li>    
            <li>&nbsp; return isPrime;</li>
            <li>}</li>        
          </ol>
        </div>
        
        <p>Here’s how it works in essence: By default, say that the number that we feed in (call this the “target” number) <em class="italic">is</em> a prime. Give that answer back – unless the target number is found to be divisible by some other number – then confirm it’s not a prime.</p> 
          
        <p>For loops are back, this time allowing us to check all the possible factors between 2 and half of the target number - because the lowest number that could be a factor that we are interested in is 2, and the highest one we need to check is half the target number – you can’t have a factor that’s bigger than half the target, so let’s not bother checking those.</p>

        <p>After line 6 sets up this loop for us, line 7 does the mathsy bit. This line basically asks “if you divide the target number by the (possible) factor we’re currently checking, do you get a remainder of zero?”.</p> 
          
        <p>Note that JavaScript doesn’t read <span class="inline-code">%</span> as “percent”. In fact, it’s a <span class="inline-code">modulus operator</span>, and will give you the remainder from a division operation. We use it here because, if you can divide the target number by another (greater than 1) number and there’s no remainder, then the target number isn’t prime.</p> 
          
        <p>If this is the case, we can move onto the next line, which is the line that ensures our function will now return the answer: <span class="inline-code">false</span>. However, if we loop through all the possible factors with line 6, and never find the condition on line 7 to be true, that means we’ve found a prime, and the function will return the answer <span class="inline-code">true</span>.</p>

        <p>You use the prime function by “calling” it, and passing in the number you want to know about. Here's some function calls and expected returns:</p>

        <div class="terminal">
          <p class="code">
            > prime(9);<br>
            false<br>
            <br>
            > prime(13);<br>
            true<br>
            </p>
        </div>  

        <p>We can also pass in some pretty big numbers:</p>

        <div class="terminal">
          <p class="code">
            > prime(479001599);<br>
            true<br>
            <br>
            > prime(389472933);<br>
            false<br>
            </p>
        </div> 
        
        <p>Unfortunately my computer doesn’t have enough memory to check the likes of such illustrious primes as <span class="inline-code">393050634124102232869567034555427371542904833</span> (yes that <a href="https://en.wikipedia.org/wiki/List_of_prime_numbers" target="_blank">really is</a> a prime) or <span class="inline-code">11111111111111111111111</span> (<a href="https://en.wikipedia.org/wiki/List_of_prime_numbers" target="_blank">same</a>) with my prime function, but if it did, in principle, my function should be able to give us an answer.</p>

        <p>With our prime function working, let’s work out how to make a spiral!</p>
      
      </div>  
      <div id="questions">

        <a href="#prime-func"><i class="fas fa-chevron-up" aria-label="up"></i></a>  
        <h3>Three questions</h3>
        <a href="#traversing"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>Picture a print head that starts on the center span, and which moves in a spiral over the grid, colouring in spans that represent prime numbers. We’re not really going to program a print head, it’s just a useful metaphor for thinking about the problem. This metaphorical print head has three questions for us:</p>

        <ul class="questions">
          <li>How do I check if the <strong>current span is prime</strong>, and <strong>colour it in</strong> if so?</li>
          <li>How do I <strong>move to a neighbouring span</strong>?</li>
          <li>How do I <strong>change direction</strong> when a corner of the spiral is reached?</li>
        </ul>  

        <p>Let’s start answering those questions.</p>

      </div>
      <div id="traversing">

        <a href="#questions"><i class="fas fa-chevron-up" aria-label="up"></i></a>  
        <h3>Traversing the grid</h3>
        <a href="#colouring"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>Remember that the spans will be laid out in the grid like words on a page – left to right, starting from the top. As we pushed them into an array, we can access them via their indexes. We can get the index of the span that will end up in the centre of the grid to start our spiral with the following:</p>

        <div class="terminal">
          <p class="code">let currentIndex = (gridSize / 2) + (gridLength / 2);</p>
        </div> 

        <p>That’s basically JavaScript for “go half way down, and half way across, and call that position the current index”. Then, to effectively “move” one cell to the right, we plus 1 to the current index. To move one left, we minus 1. Vertical movement is just like skipping a whole line - to move one down, we skip forward by as many cells as the grid is wide, and to move up, we skip backwards by that same number.</p>

        <p>You can see this with the 10 x 10 grid below. The print head moves around the indexes of the spans, which I’ve written into the below grid. If it’s currently at the span with an index of 55, then it can move one square to the right by moving to the span with an index of 55 + 1. Move left with 55 - 1. To move one square up from 55, we minus the total grid length (which in this case is 10) thus moving onto the span with the index of 45. Move down with 55 + the total grid length, thus moving to 65.</p>

        <div id="traGrid" class="tra-grid"></div>

        <p>You might notice that the first span has an index of 0. We also started at 0 in our first for loop. Why? Computers generally count things starting at 0, it means common mathematical operations <a href="https://www.johndcook.com/blog/2008/06/26/why-computer-scientists-count-from-zero/" target="_blank">use less memory</a>, which was important in the early days of computing when memory was scarce. These days, for the sort of computing I’ve been doing, at least, there’s more than enough memory to go around to start counting at 1, but optimisation considerations are still important for larger or more numerous sets of operations, and so the 0 indexing tradition has continued, at least in the C based programming languages – the family of languages to which JavaScript belongs.</p>

        <p>Back to the grid. We can move around the grid by making modifications to the current index with:</p>

        <div class="terminal">
          <p class="code">
            let right = 1;<br>
            let left = -1;<br>          
            let down = +gridLength;<br>
            let up = - gridLength;<br>
            <br>
            let directions = [up, left, down, right];
            </p>
        </div> 

        <p>We’ll want to use these directional values at predictable points in the spiralling algorithm, so we store them in an array for easy access when it comes to that. </p>

      </div>      
      <div id="colouring">
      
        <a href="#traversing"><i class="fas fa-chevron-up" aria-label="up"></i></a>    
        <h3 >Colouring in the primes</h3>
        <a href="#spiral"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>We want to check every span in the grid, colouring it in if it is prime. As we’re checking a series of things again (in this case, span elements that we pushed into an array) we can do this with a for loop, which we will tell to run as many times as there are spans in the grid – <span class="inline-code">gridSize</span> many times:</p>

        <div class="terminal">
          <p class="code">
            for (let i = 1; i <= gridSize; i += 1) {
          </p>
        </div>  

        <p>We can now call upon our prime checker function that we defined above inside this new for loop:</p>
          
        <div class="terminal">
          <p class="code">
            if (prime(i)) {<br>
            &nbsp; spanArray[currentIndex].classList.add("prime");<br>
            }       
          </p>
        </div> 
          
        <p>This is “function composition”, where we write discrete bits of code that perform distinct operations so that they are reusable in larger, more complex functions. It makes it a bit easier for us keep track of what we’re doing inside the current algorithm if we’re not also trying to parse the prime function at the same time.</p>
        
        <p>The body of the above condition basically says: apply the style class <span class="inline-code">"prime"</span> to that span - remember setting this class up in our CSS file above? It’s not a lot of styling, and we could have handled it here in the JavaScript file, but in general, it’s good keep styling concerns separate from logic concerns, even if the code is minimal. If anyone wanted to update the overall colour scheme of the spiral (…I’m not a designer, so no offense taken!) they don’t really want to have to pick through the JavaScript algorithms to do that. </p> 

        <p>Having checked the first span, we then want to move to the next one. We can do this by re-assigning the value of the <span class="inline-code">currentIndex</span>. How? We're going to make use of another variable that we'll call <span class="inline-code">currentDirection</span>. <span class="inline-code">currentDirection</span> is always going to be a number that corresponds to one of the elements in our directions array. We'll see how that works in the next section.</p>

        <p>We also want to decrement the value of something called <span class="inline-code">stepsRemaining</span>.</p>

        <div class="terminal">
          <p class="code">
            currentIndex += directions[currentDirection];<br>
            stepsRemaining -= 1;
          </p>
        </div>  

        <p><span class="inline-code">stepsRemaining</span> until what? That does sound a bit ominous.</p> 

        <p>But it’s not. It’s all to do with how we spiral… </p>

      </div>
      <div id="spiral">

        <a href="#colouring"><i class="fas fa-chevron-up" aria-label="up"></i></a>
        <h3 >Moving in a spiral</h3>
        <a href="#answers"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>To move in a spiral, the print head will set out in one direction, and check some number of spans before making a 90 degree turn anticlockwise. Then, it will check another series of spans, before turning again, and so on…</p> 
          
        <p>To work out how to write a spiralling algorithm, we need to figure out the relationship between the natural numbers, and turns of the spiral. Let’s mark out the straight sides of the spiral with different colours – we’ll call these “paths”. Paths get longer as we spiral outwards. Can you see the <strong>pattern</strong> that holds between the sequence of natural <strong>numbers</strong> and the <strong>length of the paths</strong>? (Hint: the colours might help…)</p>

        <div id="pathsGrid" class="paths-grid"></div>

        <p>Perhaps you spotted that the paths <strong>increase in length by one</strong> span on <strong>every other turn</strong> of the spiral. In other words, every other time the print head traverses one of these paths and turns 90 degrees anti-clockwise, the length of the next two paths increases by 1. That’s quite a straight forward relationship.</p>

        <p>We now need a way to take note of the number of spans left to check on the current path before the print head should turn, and a way to keep note of the current path length. We’ll do the former with that (not so) ominous variable <span class="inline-code">stepsRemaining</span>, and the latter with another variable, <span class="inline-code">pathsTraversed</span>.</p>

        <h4>When stepsRemaining is 0…</h4>

        <p>A lot of the action happens when <span class="inline-code">stepsRemaining</span> is 0 – or, in other words, when the print head is at the end of a path, and at a corner of the spiral. At this point, we need to do a number of things. Firstly, we need to increase the number of paths traversed (important to keep track of so we can increase the path length every other time this happens). </p>

        <div class="terminal">
          <p class="code">
            if (stepsRemaining === 0) {<br>
            &nbsp; pathsTraversed += 1;      
          </p>
        </div> 

        <p>Secondly, we need to check if this is indeed one of those times that the path length should increase. The below if condition checks if <span class="inline-code">pathsTraversed</span> is an odd number – which it will be every other time we traverse a path. If this is so, <span class="inline-code">pathLength</span> goes up by 1. Note: the <span class="inline-code">%</span> in the if condition is another modulus operator .</p>

        <div class="terminal">
          <p class="code">
            if (pathsTraversed % 2 === 1) {<br>
            &nbsp; pathLength += 1;<br>      
          </p>
        </div> 

        <p>Finally, we need to change direction. We can do that by cycling through the directions array and setting <span class="inline-code">currentDirection</span> to represent the <em class="italic">index</em> of the next element along in the directions array.</p> 

        <div class="terminal">
          <p class="code">
            currentDirection = (currentDirection + 1) % 4;<br>
            stepsRemaining = pathLength;<br>      
          </p>
        </div>

        <p>Another modulo! This one just lets us go back to the first index of the directions array once we reach the end, just what we want for repeated spiralling turns. At this point, we also reset <span class="inline-code">stepsRemaining</span> so that it’s equal to the path length we incremented earlier, making it ready for the next run of the for loop and the next side of the spiral.</p>        

        <h4>When stepsRemaining isn't 0…</h4>

        <p>What about if <span class="inline-code">stepsRemaining</span> isn’t 0 – either because we never entered the above if condition which checks for when it is – or because we’ve just finished going through that if condition, and <span class="inline-code">stepsRemaining</span> has been reset to the <span class="inline-code">pathLength</span>?</p>

        <p>Well, if this is the case, then we’re all finished checking the prime-i-ness of the span; working out where we are along the current path, and when we want to turn, so the only thing left to do is to move on to the next span, so we can start over. We do this by updating the value of <span class="inline-code">currentIndex</span> so that it’s equal to one more step in whatever direction we are currently going.</p>        

        <div class="terminal">
          <p class="code">
            currentIndex += directions[currentDirection];<br> 
            &nbsp; stepsRemaining -= 1;    
          </p>
        </div> 

        <p>What next? Back for several thousand more goes through the whole for loop that we began at the start of the <a href="#colouring">Colouring in the primes</a> section, probably, repeating all of the above, until all spans have been checked and either coloured in or passed over.</p>

        <h4>Sending it all into the DOM</h4>

        <p>There's one final piece to the puzzle, and that's rendering the spiral on the webpage. Our work in the JavaScript file has been to essentially work through the <span class="inline-code">spanArray</span> (the list of spans), applying a style class to spans that represent primes in the spiral layout. It feels more complex than that because we haven't been working through the spans in the order in which they appear in the list, but in the order that a spiralling print head would traverse over them were they to be layed out in a grid already.</p> 
          
        <p>But now that this list is appropriately styled, we can render it in the standard order, from lowest to highest index. This means we can use a straight-forward for loop to append the spans to the mainGrid container (this is the container we styled in CSS with our required dimensions and colours earlier).</p>

        <p</p>

        <div class="terminal">
          <p class="code">
            let fragment = d.createDocumentFragment();<br>  
            for (let i = 0; i < spanArray.length; i += 1) {<br>
            &nbsp; fragment.append(spanArray[i]);<br>
            }<br>
            <br>    
            mainGrid.append(fragment);
          </p>
        </div> 

        <p>We avoid rendering each span to the page individually as the final step in the for loop which handles the spiral. We instead append the spans to a temporary container, called a document fragment, which we can use to populate the grid on the page in one go. This is because it's expensive in terms of processing resource to interact with the Document Object Model, or "DOM" (the data structure to which the browser refers to render a webpage), and so it's preferable to do this just once, rather than 10,000 times.</p>
      
      </div>      
      <div id="answers">

        <a href="#spiral"><i class="fas fa-chevron-up" aria-label="up"></i></a>
        <h3>Three answers</h3>
        <a href="#shebang"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>We can now give the humble print head its answers:</p>

        <ul class="questions">
          <li>How do I check if the <strong>current span is prime</strong>, and <strong>colour it in</strong> if so?
            <ul class="answers">
              <li>Call the <strong>prime function</strong>, apply a <strong>class</strong>, and let <strong>CSS</strong> handle the styling.</li>
            </ul>
          </li>        
          <li>How do I <strong>move to a neighbouring span</strong>?
            <ul class="answers">
              <li>Reassign the value of the <strong>index of the span you’re currently at</strong> using the values defined in the <strong>directions array</strong>.</li>
            </ul>
          </li>
          <li>How do I <strong>change direction</strong> when a corner of the spiral is reached?
            <ul class="answers">
              <li><strong>Keep track of how many spans there are left to check on the current path</strong>, and when you get to the end, use the <strong>next value in the directions array</strong>. Oh, and if you are on an odd numbered path, <strong>add one more step to the next two paths</strong> you traverse so that the spiral can grow.</li>
            </ul>
          </li>  
        </ul>

        <p>And that’s it – that’s the Ulam spiral!</p>

        <div id="mainGrid" class="main-grid"></div>

      </div>      
      <div id="shebang">

        <a href="#answers"><i class="fas fa-chevron-up" aria-label="up"></i></a>
        <h3>The whole shebang</h3>
        <a href="#next"><i class="fas fa-chevron-down" aria-label="down"></i></a>
        
        <p>Here's the JavaScript code in full from the <span class="inline-code">scripts/ulam.js</span> file:</p>

        <div class="terminal">
          <p class="code">
            (d => {<br>
              &nbsp; <span class="comment">// Prime function</span><br>          
              &nbsp; let prime = num => {<br>
              &nbsp;&nbsp; let isPrime = true;<br> 
              &nbsp;&nbsp; if (num <= 1) {<br>
              &nbsp;&nbsp; &nbsp; isPrime = false;<br>
              &nbsp;&nbsp; } else {<br> 
              &nbsp;&nbsp; &nbsp; for (i = 2; i <= (num / 2); i += 1) {<br>
              &nbsp;&nbsp; &nbsp; &nbsp; if (num % i === 0) {<br>
              &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; isPrime = false;<br>
              &nbsp;&nbsp; &nbsp; &nbsp; }<br>
              &nbsp;&nbsp; &nbsp; }<br>   
              &nbsp;&nbsp; }<br>    
              &nbsp;&nbsp; return isPrime;<br>
              &nbsp; }<br> 
              <br>
              &nbsp; <span class="comment">// Build an array of span elements</span><br>
              &nbsp; let gridLength = 100;<br>
              &nbsp; let gridSize = gridLength * gridLength;<br>
              &nbsp; let spanArray = [];<br> 
              <br>
              &nbsp; for (let i = 0; i < gridSize; i += 1) {<br>
              &nbsp; &nbsp; span = d.createElement("span");<br>
              &nbsp; &nbsp; spanArray.push(span);<br>    
              &nbsp; }<br>
              <br>
              &nbsp; <span class="comment">// The position of the print head, starting in the center</span><br>
              &nbsp; let currentIndex = (gridSize / 2) + (gridLength / 2);<br>  
              <br>
              &nbsp; <span class="comment">// Directions: differences in span indexes as the print head moves</span><br>
              &nbsp; let up = -gridLength;<br>
              &nbsp; let down = +gridLength;<br>
              &nbsp; let right = 1;<br>
              &nbsp; let left = -1;<br>
              &nbsp; let directions = [up, left, down, right];<br>
              <br>
              &nbsp; <span class="comment">// Current direction of travel of the print head</span><br>
              &nbsp; let currentDirection = 0;<br>  
              &nbsp; <span class="comment">// Spans left to check before turning</span><br>
              &nbsp; let stepsRemaining = 1;<br>
              &nbsp; <span class="comment">// A path is the total straight side of the spiral before a turn is made</span><br> 
              &nbsp; let pathLength = 1;<br>
              &nbsp; <span class="comment">// This accounts for tight spiraling at the start of the loop (it should not increment until two directional turns)</span><br>
              &nbsp; let pathsTraversed = -1;<br>
              <br>
              &nbsp; <span class="comment">// Step through the natural numbers</span><br>
              &nbsp; for (let i = 1; i <= gridSize; i += 1) {<br>
              <br>
              &nbsp; &nbsp; <span class="comment">// If no steps remain, the print head is at the end of a path. Log that with pathsTraversed.</span><br>
              &nbsp; &nbsp; if (stepsRemaining === 0) {<br>
              &nbsp; &nbsp; &nbsp; pathsTraversed += 1;<br>
              <br>
              &nbsp; &nbsp; &nbsp; <span class="comment">// On paths of an odd number, increase the path length</span><br> 
              &nbsp; &nbsp; &nbsp; if (pathsTraversed % 2 === 1) {<br>
              &nbsp; &nbsp; &nbsp; &nbsp; pathLength += 1;<br>
              &nbsp; &nbsp; &nbsp; }<br>
              &nbsp; &nbsp; &nbsp; <span class="comment">// Change direction and reset steps remaining</span><br>
              &nbsp; &nbsp; &nbsp; currentDirection = (currentDirection + 1) % 4;<br>
              &nbsp; &nbsp; &nbsp; stepsRemaining = pathLength;<br>
              &nbsp; &nbsp; }<br>
              <br>
              &nbsp; &nbsp; <span class="comment">// Apply the prime style class</span><br>
              &nbsp; &nbsp; if (prime(i)) {<br>
              &nbsp; &nbsp; &nbsp; spanArray[currentIndex].classList.add("prime");<br>
              &nbsp; &nbsp; }<br>
              <br>
              &nbsp; &nbsp; <span class="comment">// Move print head one square in current direction</span><br>
              &nbsp; &nbsp; currentIndex += directions[currentDirection];<br>
              &nbsp; &nbsp; stepsRemaining -= 1;<br>
              &nbsp; }<br>
              <br>
              &nbsp; <span class="comment">// Append span array elements to a fragment, to send back to DOM in one go</span><br>
              &nbsp; let fragment = d.createDocumentFragment();<br>
              &nbsp; for (let i = 0; i < spanArray.length; i += 1) {<br>
              &nbsp; &nbsp; fragment.append(spanArray[i]);<br>
              &nbsp; }<br>  
              <br>
              &nbsp; mainGrid.append(fragment);<br>    
            <br>
            })(document);
          </p>
        </div> 

      </div>      
      <div id="next">

        <a href="#answers"><i class="fas fa-chevron-up" aria-label="up"></i></a>  
        <h3>What next?</h3>
        <h4>Optimisation, reusability, interactivity...</h4>
        <a href="#thanks"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>If JavaScript is doing the hard work for us, why stop at a 100 X 100 grid? Why not fill the whole page?</p>   
        
        <p>Here's how we set things up: before we ask for the grid to be rendered in the browser, we’re calling that prime function for each number up to 10,000. Remember that the prime function itself checks every possible factor of each number passed to it. That means that by the time we get to prime spans on the outermost paths of the spiral, JavaScript is checking close to 50,000 possible factors before colouring each one in.</p>

        <p>That’s a lot of calculations! And yet, for a 100 x 100 grid, the whole thing can still be done in a fraction of a second. But the relationship between the grid size and the total number of possible factors that must be checked across the grid is not linear, the latter increases at a much higher rate than the former. This bears out experimentally: A 150 x 150 grid using my current methodology takes a few seconds to fully render. I haven’t had the patience to hang around for long enough to see whether a 200 x 200 grid will ever get there. What to do?</p>

        <p>One thing we could do is to separate the prime-computation operations from the spiral-rendering operations. Rather than calling the prime checker function from inside the spiral algorithm, we could instead use the prime checker function to precompute a list of primes, and store those in a file that the spiral algorithm can access. That way, the rendering of the spiral isn’t reliant on the really computationally heavy bit: running through all the possible factors for all the given numbers.</p>

        <p>I expect there's some optimisation we can do on the prime checker function to slash the number of possible factors we’re checking – I don’t have formal training in that sort of thing, so it will take a bit of research before I can improve the function that way, but I've got some ideas. I’m hoping the pre-computing approach will optimise the project sufficiently to get some bigger grids into the browser, so this is my next step.</p>

        <p>Once I’ve managed that, I think it might be nice to be able to give viewers some control over the dimensions of the grid via inputs or sliders that represent possible dimensions. Another aim is to get the spiral into one of the JavaScript frameworks, and maybe into some component libraries. I mean, you <em class="italic">just never know</em> when you might need to pop a quick Ulam spiral into that React todo list app you’re building.</p>

        <p>So, the project is far from over! I’m not even faintly eyeing up any other famous mathsy spirals and thinking about having a go at building them any time soon… </p>

        <img class="fib" src="../assets/fib-spiral.svg" alt="A very faint blue fibonacci spiral">
      
      </div>
      <div id="thanks">

        <a href="#next"><i class="fas fa-chevron-up" aria-label="up"></i></a> 
        <h3>Thanks for reading!</h3>

        <p>If you got this far, then you might be interested in what else I'm up to. Check out my <a href="https://ammersive.github.io/portfolio/" target="_blank" rel="noopener noreferrer">portfolio site</a> and my <a href="https://github.com/ammersive/" target="_blank" rel="noopener noreferrer">Github</a>. And do feel free to reach out on <a href="https://twitter.com/ammersive" target="_blank" rel="noopener noreferrer">Twitter</a> and <a href="https://www.linkedin.com/in/ammersive/" target="_blank" rel="noopener noreferrer">LinkedIn</a>.</p>

        <p>Oh, and before you go, here's a cool transformed version of the Ulam spiral that I'm using for the background of this page to really show up all those mysterious patterns :)</p>

        <img class="transformed" src="../assets/ulam-transformed1.jpg" alt="">
      
      </div> 
    </article>
    
  <section>  
</body>
</html>