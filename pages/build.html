<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"> 
  <meta http-equiv="x-ua-compatible" content="ie=edge">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ulam Spiral</title>
  <meta name="description" content="">  

  <script defer src="../traversal/traversal.js"></script>
  <script defer src="../spiral-nums/spiral-nums.js"></script>
  <script defer src="../paths/paths.js"></script>
  <script defer src="../app.js"></script>
  <script src="https://kit.fontawesome.com/2e178b2af8.js" crossorigin="anonymous"></script> 

  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Bodoni+Moda:wght@500&family=IBM+Plex+Mono&family=Poppins:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="../styles/main.css">

</head>

<body>
  <section class="container">

    <article class="article">

      <header class="page-header" id="page-header">
          <h1>Building a Javascript<br> Ulam spiral</h1>
          <p class="author">by <a href="https://ammersive.github.io/portfolio/" target="_blank" rel="noopener noreferrer">Sophie Stammers</a></p>
      </header>

      <h2>Contents</h2>
      <ul class="contents">
        <li><a href="#building">Building the grid</a></li>
        <li><a href="#prime-func">Prime checker function    </a></li>
        <li><a href="#layout">The layout of the spiral</a></li>
        <li><a href="#moving">Moving around the grid</a></li>
        <li><a href="#colouring">Colouring in the primes</a></li>
        <li><a href="#spiral">Moving in a spiral</a></li>
        <li><a href="#answers">Answering the print head’s questions</a></li>
        <li><a href="#shebang">The whole shebang</a></li>
        <li><a href="#next">What next?</a></li>
      </ul>

      <p>Prime numbers (those that are divisible by only themselves and one) are mathematically wild. Unlike, say, the even numbers, the primes famously elude the capture and discipline of a neat mathematical formula. Compare: For any given even number, we have a tidy formula from which we can tell where we’ll find the next even number, it’s just n + 2. Not so for the primes. Take your favourite prime number. Maybe it’s 3, or 17, or even 65537. There is currently no known generalisable mathematical statement from which we can derive how far up the sequence of natural (whole) numbers the next prime lies.</p> 

      <p>So, are the primes scattered at random through the sequence of natural numbers? No! There’s some difficult maths we can do to reveal that order and predictability pervades at least some subsets of the primes, but there’s actually a much easier little conjuring trick we can perform to unveil a series of sequences and patters that dwell amongst the primes, which even that difficult maths itself cannot wholly explain – and – we can do it using just coloured pencils and graph paper!</p> 

      <p>In principle, at least. For whilst this conjuring trick is easy, it certainly is repetitive. Here’s the deal. Put your pencil in the middle of the graph paper and write a “1”. Go up one square and write “2”. Go left and write “3”. Keep going, inputting the next number to the next square, working in a tight spiral around 1 until you have something that looks like this:</p>  

      <div id="spiGrid" class="spi-grid"></div>

      <p>Now, go around again, but this time, every time you find a prime number, colour in that square. If you have the patience to do this for all of the cells in, say, a 100 x 100 grid, you will witness the emergence of a haunting and beautiful pattern, in which many of the prime numbers – far more than would be expected by chance, and far more than for a number series that is truly, untameably wild –  line up in long diagonal stretches that criss-cross the page.</p> 

      <p>Alas, dear reader. I do not have this patience. But, I have always had a deep desire to generate for myself the mysterious Ulam spiral (first discovered by mathematician Stanisław Ulam in 1963, and popularized by Martin Gardner) in some way. The precise way became clear last year as I decided to retrain as a web developer: I could get my computer to do the colouring in bit for me.</p>

      <p>There are three stages to the project:</p>
      
      <ol class="list">
        <li>Create a <strong>grid of squares</strong>, where we have <strong>control over the colour</strong> of the squares.</li> 
        <li>Write a bit of code that can <strong>identify if a number is prime</strong></li>
        <li>Write a bit of code that specifies the <strong>spiralling movement across the grid</strong></li>
      </ol>
      
      <p>Let's get started!</p>

      <div id="building">

        <a href="#page-header"><i class="fas fa-chevron-up" aria-label="up"></i></a>
        <h3>Building the grid</h3>
        <a href="#prime-func"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>I’ve chosen to go with a 100 x 100 grid, which means we need to create 10,000 grid squares. We’ll be using the HTML equivalent of a square, an element called a <em>span</em>. We can then use the styling language CSS to tell these spans how big and what colour to be. So, from now on I’ll talk about “spans” – just think of them as squares that we can display on a webpage.</p> 

        <p>We want each span to be pretty much identical except for whether or not they are coloured in. So, here’s our first job for Javascript, the programming language we’ll be using to get the main logic into the project. Let’s first declare some variables – words that will store the values of important data that we’ll want to reuse in the project. We said that the grid would be 100 spans wide/high, so we’ll store that value in a <span class="inline-code">gridLength</span> variable, which we can multiply by itself to get the total number of spans in the grid (<span class="inline-code">gridSize</span>), which will also be an important value to keep track of for later. Now let’s make lots of spans!</p>

        <div class="terminal">
          <ol class="code">
            <li>let gridLength = 100;</li>
            <li>let gridSize = gridLength * gridLength;</li>
            <li>let spanArray = [];</li>
            <li>for (let i = 0; i < gridSize; i += 1) {</li>
            <li>&nbsp; span = d.createElement("span");</li>
            <li>&nbsp; spanArray.push(span);</li>    
            <li>}</li>
          </ol>
        </div> 

        <p>The main “making” action happens on line 4, the line that starts with the word “for”, up to line 7. We have here a fundamental computing procedure known as a loop (in this case, a “for loop”), which allows us perform some given operation over and over again, until some condition is met. The operation running inside this loop (lines 5 and 6) is just about interpretable in plain English – it basically says: create a span, and then put that span inside a thing we’re calling <span class="inline-code">spanArray</span>. An array is a way to store data. It’s a container where we can keep the spans together, and use them later. Line four is the bit that specifies how many spans we should make: start a count at 0, and then make a span, and every time we make a span, plus one to this count. Repeat this procedure over and over, stopping when the count count reaches the number stored in the variable <span class="inline-code">gridSize</span>, which is 10,000.</p>

        <p>We now have 10,000 spans, stored in a list and ready to go. That was quick! We still need to do a bit of styling to get things looking grid-like. For one thing, need to actually put them on our page, but we’ll do that right at the end when we’ve done the prime number bit. At present, these spans won’t have any dimensions, or colours, which they will need if we want to actually see them on our page. We can fix that with some CSS. Let’s first make a container to house our spans giving it a width and a height neatly divisible by 100, since we chose to have 100 spans per row/column.</p>
        
        <div class="terminal">
          <ol class="code">
            <li>.main-grid {</li> 
            <li>&nbsp; width: 600px;</li> 
            <li>&nbsp; height: 600px;</li>
            <li>}</li>         
          </ol>
        </div> 

        <p>Then we can tell each span element to be one-hundredth of the total grid height and length, they’ll fit nicely then. By default, the spans want to stack on top of each other, in a long line vertically down the page. <span class="inline-code">float: left</span> tells them to fill the first row, sitting next to each other until they reach the edge of the grid, and then fill the next row… and so on. We’ll also give them a nice minty colour so we can see them.</p> 

        <div class="terminal">
          <ol class="code">
            <li>span {</li>
            <li>&nbsp; height: 6px;</li>
            <li>&nbsp; width: 6px;</li>  
            <li>&nbsp; box-sizing: border-box;</li>
            <li>&nbsp; float: left;</li>
            <li>&nbsp; background-color: rgb(200, 249, 232);</li>  
            <li>}</li>        
          </ol>
        </div> 

        <p>Even though we have made a grid here, for now it will look like a big minty square because the spans have no borders to differentiate them. We want it to be this way, since the thing we want to differentiate is the prime squares, which we’ll do later, but we can add a temporary border style to check things are as they should be with <span class="inline-code">border: solid 1 px blue;</span> for instance. This is also why we’ve set the box-sizing to border-box, so the addition of a test border won’t increase the size of the spans.</p>

        <p>Let’s get colouring in some primes!</p>

      </div>

      <div id="prime-func">

        <a href="#building"><i class="fas fa-chevron-up" aria-label="up"></i></a>  
        <h3>Prime checker function</h3>
        <a href="#layout"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>Before we tell Javascript to get out its coloured pencils and go to town on our grid, we need a way to work out, for any given number: is that number a prime? I’m going to do this with a function, a reusable bit of code that allows us ask that same question, but feed in any number of different values (which is useful, because there are quite a lot of numbers out there…). Here it is:</p>

        <div class="terminal">
          <ol class="code">
            <li>let prime = num => {</li>
            <li>&nbsp; let isPrime = true;</li> 
            <li>&nbsp; if (num <= 1) {</li>
            <li>&nbsp; &nbsp; isPrime = false;</li>
            <li>&nbsp; } else {</li> 
            <li>&nbsp; &nbsp; for (i = 2; i <= (num / 2); i += 1) {</li>
            <li>&nbsp; &nbsp; &nbsp; if (num % i === 0) {</li>
            <li>&nbsp; &nbsp; &nbsp; &nbsp; isPrime = false;</li>
            <li>&nbsp; &nbsp; &nbsp; }</li>
            <li>&nbsp; &nbsp; }</li>   
            <li>&nbsp; }</li>    
            <li>&nbsp; return isPrime;</li>
            <li>}</li>        
          </ol>
        </div>
        
        <p>Here’s how it works in essence: By default, say that the number that we feed in (call this the “target” number) IS a prime. Give that answer back – unless that target number is found to be divisible by some other number – then confirm it’s not a prime. For loops are back - this time allowing us to check all the possible factors between 2 and half of the target number - because the lowest number that could be a factor that we are interested in is 2, and the highest one we need to check is half the target number – you can’t have a factor that’s bigger than half the target, so let’s not bother checking more than that.</p>

        <p>After line 6 sets up this loop for us, line 7 does the mathsy bit. This line basically asks “if you divide the target number by the (possible) factor we’re currently checking, do you get a remainder of zero?”. Note that Javascript doesn’t read <span class="inline-code">%</span> as “percent”. In fact, it’s a <span class="inline-code">modulo operator</span>, and will give you the remainder from a division operation. We use it here because, if you can divide the target number by another (greater than 1) number and there’s no remainder, then the target number isn’t prime. If this is the case, we can move onto the next line, which is the line that ensures our function will now return the answer: <span class="inline-code">false</span>. However, if we loop through all the possible factors with line 6, and never find the condition on line 7 to be true, that means we’ve found a prime, and the function will return the answer <span class="inline-code">true</span>.</p>

        <p>You use the prime function by “calling” it, anywhere else in the code below, and passing in the number you want to know about, like this:</p>

        <div class="terminal">
          <p class="code">
            > prime(9);<br>
            false<br>
            <br>
            > prime(13);<br>
            true<br>
            </p>
        </div>  

        <p>We can also pass in some pretty big numbers:</p>

        <div class="terminal">
          <p class="code">
            > prime(479001599);<br>
            true<br>
            <br>
            > prime(389472933);<br>
            false<br>
            </p>
        </div> 
        
        <p>Unfortunately my computer doesn’t have enough memory to check the likes of such illustrious primes as <span class="inline-code">393050634124102232869567034555427371542904833</span> (yes that <a href="https://en.wikipedia.org/wiki/List_of_prime_numbers" target="_blank">really is</a> a prime) or <span class="inline-code">11111111111111111111111</span> (<a href="https://en.wikipedia.org/wiki/List_of_prime_numbers" target="_blank">same</a>) with my prime function, but if it did, in principle, my function should be able to give us an answer.</p>

        <p>With our prime function working, let’s work out how to make a spiral!</p>
      
      </div>  

      <div id="layout">

        <a href="#prime-func"><i class="fas fa-chevron-up" aria-label="up"></i></a>  
        <h3>The layout of the spiral</h3>
        <a href="#moving"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>A disclaimer before we dive into the spiralling algorithm: Because I am assuming that you, dear reader, are a human, and not the JavaScript engine, this part lends itself to a narrative that does not precisely follow the order of the code itself from top to bottom. For brevity, I won’t discuss explicitly how and when every variable is declared and initialised. I think it will be easier to understand why we’d want to store a particular value if we encounter it already at work in the ecosystem of the algorithm. So, if you’re interested in getting the full scoop on where variables are declared, and with what initial values, as well as the precise scope everything lies within, do check the code itself <a href="https://github.com/ammersive/ulam" target="_blank">here</a> as you read.</p>

        <p>Now, picture a print head that starts on a central span, that we’ll imagine represents the first of the natural numbers, as above, and which moves over the grid, checking spans in ascending order, and colouring those it finds to harbour primes. We’re not really going to program a print head, it’s just a useful metaphor for thinking about the problem. This metaphorical print head has three questions for us:</p>

        <ul class="questions">
          <li>How do I check if the <strong>current span is prime</strong>, and <strong>colour it in</strong> if so?</li>
          <li>How do I <strong>move to a neighbouring span</strong>?</li>
          <li>How do I <strong>change direction</strong> when a corner of the spiral is reached?</li>
        </ul>  

        <p>Let’s start answering those questions.</p>

      </div>  

      <div id="moving">

        <a href="#layout"><i class="fas fa-chevron-up" aria-label="up"></i></a>  
        <h3>Moving around the grid</h3>
        <a href="#colouring"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>Remember that the spans will be laid out in the grid like words on a page – left to right, starting from the top. As we pushed them into an array, we can access them via their indexes. We can get the index of a central cell to start our spiral with the following:</p>

        <div class="terminal">
          <p class="code">let currentIndex = (gridSize / 2) + (gridLength / 2);</p>
        </div> 

        <p>That’s basically Javascript for “go half way down, and half way across, and call that position the current index”. Then, to effectively “move” one cell to the right, we plus 1 to the current index. To move one left, we minus 1. Vertical movement is just like skipping a whole line - to move one down, we skip forward by as many cells as the grid is wide, and to move up, we skip backwards by that same number.</p>

        <p>You can see this with the 10 x 10 grid below. The print head moves around the indexes of the spans, which I’ve written into the below grid. If it’s currently at the span with an index of 55, then it can move one square to the right by moving to the span with an index of 55 + 1. To move one square up from 55, we minus the total grid length (which in this case is 10) and we can move onto the span with the index of 45.</p>

        <div id="traGrid" class="tra-grid"></div>

        <p>You might notice that the first span has an index of 0. We also started at 0 in our first for loop. Why? Computers generally count things starting at 0, it means common mathematical operations <a href="https://www.johndcook.com/blog/2008/06/26/why-computer-scientists-count-from-zero/" target="_blank">use less memory</a>, which was important in the early days of computing when memory was scarce. These days, for the sort of computing I’ve been doing, at least, there’s more than enough memory to go around to start counting at 1, but optimisation considerations are still important for larger or more numerous sets of operations, and so the 0 indexing tradition has continued, at least in the C based programming languages – the family of languages to which Javascript belongs.</p>

        <p>Back to the grid. We can move around the grid by making modifications to the current index with:</p>

        <div class="terminal">
          <p class="code">
            let right = 1;<br>
            let left = -1;<br>          
            let down = +gridLength;<br>
            let up = - gridLength;<br>
            <br>
            let directions = [up, left, down, right];
            </p>
        </div> 

        <p>We’ll want to use these directional values at similar points in the spiralling algorithm, so we’ll store them in an array for easy access when it comes to that. </p>

      </div>
      
      <div id="colouring">
      
        <a href="#moving"><i class="fas fa-chevron-up" aria-label="up"></i></a>    
        <h3 >Colouring in the primes</h3>
        <a href="#spiral"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>We want to check every span in the grid, colouring it in if it is prime. As we’re checking a series of things again (in this case, span elements that we pushed into an array) we can do this with a for loop, which we will tell to run as many times as there are spans in the grid – <span class="inline-code">gridSize</span> many times, in fact:</p>

        <div class="terminal">
          <p class="code">
            for (let i = 1; i <= gridSize; i += 1) {
          </p>
        </div>  
        
        <p>Inside the for loop, for every span we come across, there’s a few things that we want to make sure we do.</p>

        <p>Firstly, we need to check if that span is prime, and if we find that it is, colour it in. We’ve already written a function that will do this work for us, which we can now use inside our for loop. This is a practice known as “function composition”, where we take bits of code that perform a particular operation, and rather than adding additional functionality into to these, we call upon them inside another bit of code. It makes it a bit easier for us keep track of what we’re doing in our current spiralling algorithm if we’re not also trying to parse the prime function at the same time.  It pays off. The below if condition almost reads like English: “if i is prime…”</p>

        <div class="terminal">
          <p class="code">
            if (prime(i)) {<br>
            &nbsp; spanArray[currentIndex].classList.add("prime");<br>
            }       
          </p>
        </div> 

        <p>The body of the condition basically says: apply a style class (“prime”) to that span. We deal with the actual colouring elsewhere in our linked CSS style file (there, the “prime” class is basically to add a dark green colour). It’s not loads of styling, and we could have handled it here in the JavaScript file, but in general, it’s good to separate out styling concerns and the logic concerns, even if the code is only minimal. If anyone wanted to update the overall colour scheme of the page (…I’m not a designer, so no offense taken!) they don’t really want to have to pick through the JavaScript algorithms to do that. </p>

        <p>Secondly, we need to move the print head over one span in the current direction of travel. We do this by assigning a new value to the <span class="inline-code">currentIndex</span>. <span class="inline-code">currentDirection</span> is a number that corresponds to one of the elements in our directions array. I’ll discuss how we set it in just a moment.</p>

        <p>Thirdly, we minus one from the value of something called <span class="inline-code">stepsRemaining</span>.</p>

        <div class="terminal">
          <p class="code">
            currentIndex += directions[currentDirection];<br>
            stepsRemaining -= 1;
          </p>
        </div>  

        <p><span class="inline-code">stepsRemaining</span> until what? Sounds pretty…ominous. It’s not. It’s all to do with how we spiral… </p>

      </div>  

      <div id="spiral">

        <a href="#colouring"><i class="fas fa-chevron-up" aria-label="up"></i></a>
        <h3 >Moving in a spiral</h3>
        <a href="#answers"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>To move in a spiral, the print head will set out in one direction, checking some number of spans before making a 90 degree turn anticlockwise. Then, it will check another series of spans, before turning again, and so on… To work out how to write a spiralling algorithm, we need to figure out the relationship between the natural numbers, and turns of the spiral. Let’s mark out the straight sides of the spiral with different colours – we’ll call these “paths”. Paths get longer as we spiral outwards. Can you see the <strong>pattern</strong> that holds between the sequence of <strong>natural numbers</strong> and the <strong>length of the paths</strong>? (Hint: the colours might help…)</p>

        <div id="pathsGrid" class="paths-grid"></div>

        <p>Perhaps you spotted that the paths <strong>increase in length by one</strong> span on <strong>every other turn</strong> of the spiral. In other words, every other time the print head traverses one of these paths and turns 90 degrees anti-clockwise, the length of the next two paths increases by 1. That’s quite a straight forward relationship.</p>

        <p>We now need a way to take note of the number of spans left to check on the current path before the print head needs to turn, and a way to keep note of the current path length. We’ll do the former with that (not so) ominous variable <span class="inline-code">stepsRemaining</span>, and the latter with another variable, <span class="inline-code">pathsTraversed</span>.</p>

        <h4>When stepsRemaining is 0…</h4>

        <p>A lot of the action happens when stepsRemaining is 0 – or, in other words, when the print head is at the end of a path, and at a corner of the spiral. At this point, we need to do a number of things. Firstly, we need to increase the number of paths traversed (important to keep track of so we can increase the path length every other time this happens). </p>

        <div class="terminal">
          <p class="code">
            if (stepsRemaining === 0) {<br>
            &nbsp; pathsTraversed += 1;      
          </p>
        </div> 

        <p>Secondly, we need to check if this is indeed one of those times that the path length should increase. The below if condition checks if pathsTraversed is an odd number – which it will be every other time we traverse a path. If this is so, pathLength goes up by 1. Note: the <span class="inline-code">%</span> in the if condition is another modulo operator .</p>

        <div class="terminal">
          <p class="code">
            if (pathsTraversed % 2 === 1) {<br>
            &nbsp; pathLength += 1;<br>      
          </p>
        </div> 

        <p>Finally, we need to change direction. We can do that by cycling through the directions array and reseting <span class="inline-code">currentDirection</span> to be the next element along in the array, as below. Another modulo! This one just lets us go back to the start of the array once we reach the end, which is exactly what we want for repeated spiralling turns.) At this point, we should also reset <span class="inline-code">stepsRemaining</span> so that it’s equal to the path length we incremented earlier, making it ready for the next run of the for loop and the next side of the spiral.</p>

        <h4>When stepsRemaining isn't 0…</h4>

        <p>What about if <span class="inline-code">stepsRemaining</span> isn’t 0 – either because we never entered the above if condition which checks for when it is – or because we’ve just finished going through that if condition, and <span class="inline-code">stepsRemaining</span> has been reset to the <span class="inline-code">pathLength</span>?</p>

        <p>Well, if this is the case, then we’re all finished checking the prime-i-ness of the span; working out where we are along the current path, and when we want to turn, so the only thing left to do is to move on to the next span, so we can start over. We do this by updating the value of <span class="inline-code">currentIndex</span> so that it’s equal to one more step in whatever direction we are currently going.</p>

        <div class="terminal">
          <p class="code">
            currentIndex += directions[currentDirection];<br> 
            &nbsp; stepsRemaining -= 1;    
          </p>
        </div> 

        <p>What next? Back for a few more goes through the for loop, probably, repeating all this lot over and over again, for as many times as there are spans in the grid itself, until all spans have been checked and either coloured in or passed over.</p>
      
      </div>
      
      <div id="answers">

        <a href="#spiral"><i class="fas fa-chevron-up" aria-label="up"></i></a>
        <h3>Answering the print head’s questions</h3>
        <a href="#shebang"><i class="fas fa-chevron-down" aria-label="down"></i></a>

        <p>We can now give the humble print head its answers:</p>

        <ul class="questions">
          <li>How do I check if the <strong>current span is prime</strong>, and <strong>colour it in</strong> if so?
            <ul class="answers">
              <li>Call the <strong>prime function</strong>, apply a <strong>class</strong>, and let <strong>CSS</strong> handle the styling.</li>
            </ul>
          </li>        
          <li>How do I <strong>move to a neighbouring span</strong>?
            <ul class="answers">
              <li>Reassign the value of the <strong>index of the span you’re currently at</strong> using the values defined in the <strong>directions array</strong>.</li>
            </ul>
          </li>
          <li>How do I <strong>change direction</strong> when a corner of the spiral is reached?
            <ul class="answers">
              <li><strong>Keep track of how many spans there are left to check on the current path</strong>, and when you get to the end, use the <strong>next value in the directions array</strong>. Oh, and if you are on an odd numbered path, <strong>add one more step to the next two paths</strong> you traverse so that the spiral can grow.</li>
            </ul>
          </li>  
        </ul>

        <p>And that’s it – that’s the Ulam spiral!</p>

        <div id="mainGrid" class="main-grid"></div>

      </div>
      
      <div id="shebang">

        <a href="#answers"><i class="fas fa-chevron-up" aria-label="up"></i></a>
        <h3>The whole shebang</h3>
        <a href="#next"><i class="fas fa-chevron-down" aria-label="down"></i></a>
        
        <p>The javascript code in full from the app.js file</p>

        <div class="terminal">
          <p class="code">
            (d => {<br>
              &nbsp; <span class="comment">// Prime function</span><br>          
              &nbsp; let prime = num => {<br>
              &nbsp;&nbsp; let isPrime = true;<br> 
              &nbsp;&nbsp; if (num <= 1) {<br>
              &nbsp;&nbsp; &nbsp; isPrime = false;<br>
              &nbsp;&nbsp; } else {<br> 
              &nbsp;&nbsp; &nbsp; for (i = 2; i <= (num / 2); i += 1) {<br>
              &nbsp;&nbsp; &nbsp; &nbsp; if (num % i === 0) {<br>
              &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; isPrime = false;<br>
              &nbsp;&nbsp; &nbsp; &nbsp; }<br>
              &nbsp;&nbsp; &nbsp; }<br>   
              &nbsp;&nbsp; }<br>    
              &nbsp;&nbsp; return isPrime;<br>
              &nbsp; }<br> 
              <br>
              &nbsp; <span class="comment">// Build an array of span elements</span><br>
              &nbsp; let gridLength = 100;<br>
              &nbsp; let gridSize = gridLength * gridLength;<br>
              &nbsp; let spanArray = [];<br> 
              <br>
              &nbsp; for (let i = 0; i < gridSize; i += 1) {<br>
              &nbsp; &nbsp; span = d.createElement("span");<br>
              &nbsp; &nbsp; spanArray.push(span);<br>    
              &nbsp; }<br>
              <br>
              &nbsp; <span class="comment">// The position of the print head, starting in the center</span><br>
              &nbsp; let currentIndex = (gridSize / 2) + (gridLength / 2);<br>  
              <br>
              &nbsp; <span class="comment">// Directions: differences in span indexes as the print head moves</span><br>
              &nbsp; let up = -gridLength;<br>
              &nbsp; let down = +gridLength;<br>
              &nbsp; let right = 1;<br>
              &nbsp; let left = -1;<br>
              &nbsp; let directions = [up, left, down, right];<br>
              <br>
              &nbsp; <span class="comment">// Current direction of travel of the print head</span><br>
              &nbsp; let currentDirection = 0;<br>  
              &nbsp; <span class="comment">// Spans left to check before turning</span><br>
              &nbsp; let stepsRemaining = 1;<br>
              &nbsp; <span class="comment">// A path is the total straight side of the spiral before a turn is made</span><br> 
              &nbsp; let pathLength = 1;<br>
              &nbsp; <span class="comment">// This accounts for tight spiraling at the start of the loop (it should not increment until two directional turns)</span><br>
              &nbsp; let pathsTraversed = -1;<br>
              <br>
              &nbsp; <span class="comment">// Step through the natural numbers</span><br>
              &nbsp; for (let i = 1; i <= gridSize; i += 1) {<br>
              <br>
              &nbsp; &nbsp; <span class="comment">// If no steps remain, the print head is at the end of a path. Log that with pathsTraversed.</span><br>
              &nbsp; &nbsp; if (stepsRemaining === 0) {<br>
              &nbsp; &nbsp; &nbsp; pathsTraversed += 1;<br>
              <br>
              &nbsp; &nbsp; &nbsp; <span class="comment">// On paths of an odd number, increase the path length</span><br> 
              &nbsp; &nbsp; &nbsp; if (pathsTraversed % 2 === 1) {<br>
              &nbsp; &nbsp; &nbsp; &nbsp; pathLength += 1;<br>
              &nbsp; &nbsp; &nbsp; }<br>
              &nbsp; &nbsp; &nbsp; <span class="comment">// Change direction and reset steps remaining</span><br>
              &nbsp; &nbsp; &nbsp; currentDirection = (currentDirection + 1) % 4;<br>
              &nbsp; &nbsp; &nbsp; stepsRemaining = pathLength;<br>
              &nbsp; &nbsp; }<br>
              <br>
              &nbsp; &nbsp; <span class="comment">// Apply the prime style class</span><br>
              &nbsp; &nbsp; if (prime(i)) {<br>
              &nbsp; &nbsp; &nbsp; spanArray[currentIndex].classList.add("prime");<br>
              &nbsp; &nbsp; }<br>
              <br>
              &nbsp; &nbsp; <span class="comment">// Move print head one square in current direction</span><br>
              &nbsp; &nbsp; currentIndex += directions[currentDirection];<br>
              &nbsp; &nbsp; stepsRemaining -= 1;<br>
              &nbsp; }<br>
              <br>
              &nbsp; <span class="comment">// Append span array elements to a fragment, to send back to DOM in one go</span><br>
              &nbsp; let fragment = d.createDocumentFragment();<br>
              &nbsp; for (let i = 0; i < spanArray.length; i += 1) {<br>
              &nbsp; &nbsp; fragment.append(spanArray[i]);<br>
              &nbsp; }<br>  
              <br>
              &nbsp; mainGrid.append(fragment);<br>    
            <br>
            })(document);
          </p>
        </div> 

      </div> 
      
      <div id="next">

        <a href="#answers"><i class="fas fa-chevron-up" aria-label="up"></i></a>  
        <h3>What next?</h3>
        <h4>Optimisation, reusability, interactivity...</h4>

        <p>If Javascript is doing the hard work for us, why stop at a 100 X 100 grid? Why not fill the whole page?  Remember how we set things up: before we ask for the grid to be rendered in the browser, we’re calling that prime function for each number up to 10,000. Recall that the prime function itself checks every possible factor of each number passed to it. That means that by the time we get to prime spans on the outermost paths of the spiral, Javascript is checking close to 50,000 possible factors before colouring each one in.</p>

        <p>That’s a lot of calculations! And yet, for a 100 x 100 grid, they can still be done in a matter of milliseconds. But the relationship between the grid size and the total number of possible factors that must be checked across the grid is not linear, the latter increases at a much higher rate than the former. This bears out experimentally: A 150 x 150 takes a few seconds to fully render. I haven’t had the patience to hang around for long enough to see whether a 200 x 200 grid will ever get there. What to do?</p>

        <p>One thing we could do is to separate the prime-computation operations from the spiral-rendering operations. Instead of calling the prime checker function from inside the for loop that applies the prime style class to spans, we could instead use the prime checker function to precompute a list of primes, and store those in a file that the span-styling for loop can access. That way, the rendering of the spiral isn’t reliant on the really computationally heavy bit (running through all possible factors).</p>

        <p>There might also be some better maths we can do on the prime checker function to slash the number of possible factors we’re checking – I don’t have formal training in that sort of thing though, so it will take a bit of research before I can improve the function that way. I’m hoping the pre-computing approach will optimise the project sufficiently to get some bigger grids into the browser, so this is my next step.</p>

        <p>Once I’ve managed that, I think it might be nice to be able to give viewers some control over the dimensions of the grid with via inputs or sliders that represent possible dimensions. Another aim is to get the spiral into one of the Javascript frameworks, and then on into component libraries. I mean, you never know when you might need to pop a quick Ulam spiral into that React todo list app you’re building.</p>

        <p>So, the project is far from over! I’m not even faintly eyeing up any other famous mathsy spirals and thinking about having a go at building them any time soon… </p>

        <img class="fib" src="../assets/fib-spiral.svg" alt="A very faint blue fibonacci spiral">

        <h3>Thanks for reading!</h3>

        <p>If you go this far, then you might be interested in what else I'm up to. Check out my <a href="https://ammersive.github.io/portfolio/" target="_blank" rel="noopener noreferrer">portfolio site</a> and my <a href="https://github.com/ammersive/" target="_blank" rel="noopener noreferrer">Github</a>. And do feel free to reach out on <a href="https://twitter.com/ammersive" target="_blank" rel="noopener noreferrer">Twitter</a> and <a href="https://www.linkedin.com/in/ammersive/" target="_blank" rel="noopener noreferrer">LinkedIn</a>.</p>

        <p>Oh, and before you go, here's a cool transformed version of the Ulam spiral I'm using for the background of this page :)</p>

        <img class="transformed" src="../assets/ulam-transformed1.jpg" alt="">

      </div>
    </article>
    
  <section>  
</body>
</html>